#!/usr/bin/env bash

SCRIPT_NAME="$(basename "$(realpath "$0")")"

# {{{ argumnent variable definitions

DEFAULT_JOBS=8
DEFAULT_LIMIT=25
DEFAULT_DIR="$(pwd)"

DIR=""
DEPTH=0
JOBS=-1
LIMIT=-1
OWNER=""

# }}}
# {{{ functions

echo_usage() {
	local -r SCRIPT_NAME="$1"

	if [[ -z "$SCRIPT_NAME" ]]; then
		echo "* Script name not provided or empty."
		exit 1
	fi

	echo "* Usage $SCRIPT_NAME [...args]"
	echo ""
	echo "For a list of available arguments, and usage instructions, run:"
	echo "./$SCRIPT_NAME --help"
}

echo_description() {
	echo "  This script can be useful for quickly cloning a large number of"
	echo "  repositories from GitHub, especially for organizations with a large"
	echo "  number of repositories."
	echo ""
	echo "  It can also be used for backing up all of a user's or organization's"
	echo "  repositories to a local machine."
	echo ""
	echo "  By utilizing parallel jobs, the cloning process can be significantly"
	echo "  faster compared to cloning each echo repository one by one."
}

echo_flags() {
	echo "  === Flags ==="
	echo ""
	echo "  --help: Show this help text"
	echo ""
	echo "  --depth: The depth at which to clone the remote repository. Defaults"
	echo "           to -1, which is the full history. Any other value will limit"
	echo "           the clone to the specified number of commits."
	echo ""
	echo "  --dir:   Sets the directory where the repositories will be cloned."
	echo ""
	echo "  --owner: Sets the username or organization name to clone all"
	echo "           repositories for."
	echo "           This argument is required and must be followed by the desired"
	echo "           username or organization name."
	echo "           Only repositories owned by the specified user or organization"
	echo "           will be echo tloned."
	echo ""
	echo "  --limit: Sets the maximum number of repositories that will be cloned."
	echo "           This argument is optional and must be followed by a numerical"
	echo "           value. If not specified, all repositories owned by the"
	echo "           specified user or organization will be cloned."
	echo ""
	echo "  --jobs: Sets the number of clone processes to run in parallel."
	echo "          This argument is optional and must be followed by a numerical"
	echo "          value. If not specified, the default value of 1 will be used."
	echo "          Increasing the number of jobs can speed up the cloning process,"
	echo "          but may also put more strain on system resources."
	echo "          It is recommended to use a value that is appropriate for your"
	echo "          system's capabilities."
}

echo_examples() {
	local -r SCRIPT_NAME="$1"

	if [[ -z "$SCRIPT_NAME" ]]; then
		echo "Script name not provided or empty."
		exit 1
	fi

	echo "  === Examples ==="
	echo ""
	echo "  - To clone a maximum of 500 repositories owned by the user 'me'"
	echo "    using 16 parallel jobs into the current directory, run:"
	echo "    \$ ./$SCRIPT_NAME --owner me --jobs 16 --limit 500 --dir ."
	echo ""
	echo "  - To clone all repositories owned by the organization microsoft"
	echo "    using 20 parallel jobs and a max of 500 repositories, into the"
	echo "    directory at ./microsoft, you can run:"
	echo "    \$ ./$SCRIPT_NAME --owner microsoft --jobs 20 --limit 500 --dir ./microsoft"
}

echo_help() {
	local -r SCRIPT_NAME="$1"

	if [[ -z "$SCRIPT_NAME" ]]; then
		echo "Script name not provided or empty."
		exit 1
	fi

	echo_usage "$SCRIPT_NAME"
	echo ""
	echo ""
	echo_description
	echo ""
	echo ""
	echo_flags
	echo ""
	echo ""
	echo_examples "$SCRIPT_NAME"
}

# }}}
# {{{ environment validation

FOUND_ERRORS=0

GH_PATH="$(which gh)"
JQ_PATH="$(which jq)"

if [[ -z "$GH_PATH" ]]; then
	echo "Error: The GitHub CLI (gh) is required but was not found."

  FOUND_ERRORS=1
fi

# TODO: Recommend actual install commands based on distro
if [[ -z "$JQ_PATH" ]]; then
	echo "Error: The JQ utility is required but was not found."

  FOUND_ERRORS=1
fi

if [[ $FOUND_ERRORS -eq 1 ]]; then
  echo ""
  echo "See --help for usage instructions."

  exit 1
fi

# }}}
# {{{ parse arguments

for ((i = 1; i <= $#; i++)); do
	case ${!i} in
	--help)
		echo_help "$SCRIPT_NAME"
		exit 0
		;;
	--jobs)
		next_index=$((i + 1))
		JOBS=${!next_index}
		;;
	--limit)
		next_index=$((i + 1))
		LIMIT=${!next_index}
		;;
	--owner)
		next_index=$((i + 1))
		OWNER=${!next_index}
		;;
	--depth)
		next_index=$((i + 1))
		DEPTH=${!next_index}
		;;
	--dir)
		next_index=$((i + 1))
		DIR=${!next_index}
		;;
	esac
done

# }}}
# {{{ set default values

if [[ $JOBS -eq -1 ]]; then
  JOBS=$DEFAULT_JOBS
fi

if [[ $LIMIT -eq -1 ]]; then
  LIMIT=$DEFAULT_LIMIT
fi

if [[ -z "$DIR" ]]; then
  DIR="$DEFAULT_DIR"
fi

# }}}
# {{{ validate final argument values

FOUND_ERRORS=0

if [[ "$LIMIT" -lt 1 ]]; then
  echo "Error: --limit must be greater than 1"

  FOUND_ERRORS=1
fi

if [[ "$JOBS" -lt 1 ]]; then
	echo "Error: --jobs must be at least 1"

  FOUND_ERRORS=1
fi

if [[ "$DEPTH" -lt 0 ]]; then
	echo "Error: --depth must be at least 0 if provided"

  FOUND_ERRORS=1
fi

if [[ -z "$OWNER" ]]; then
	echo "Error: --owner not specified"

  FOUND_ERRORS=1
fi

if [[ ! -d "$DIR" ]]; then
	echo "Error: Output directory $DIR does not exist."

  FOUND_ERRORS=1
fi

if [[ $FOUND_ERRORS -eq 1 ]]; then
  echo ""
  echo "See --help for usage instructions."

  exit 1
fi

# }}}

echo "* Output directory: $DIR"
echo "* Cloning at most $LIMIT repositories."
echo "* Will clone $JOBS repositories concurrently."

if [[ $DEPTH -eq 0 ]]; then
  echo "* Will clone full commit histories."
else
  echo "* Will clone only the last $DEPTH commits."
fi

echo ""
echo "* Fetching repositories for $OWNER..."

GH_REPOS_LIST_JSON="$(gh repo list "$OWNER" --json name --limit "$LIMIT")"
mapfile -t GH_REPOS_LIST < <(echo "$GH_REPOS_LIST_JSON" | jq -r '.[].name')
GH_REPOS_LIST_COUNT="${#GH_REPOS_LIST[@]}"

if [[ -z "$GH_REPOS_LIST_COUNT" ]]; then
  echo "Error: Found no repositories for $OWNER."
  exit 1
fi

NEW_GH_REPOS_LIST=()
SKIP_COUNT=0

for GH_REPO in "${GH_REPOS_LIST[@]}"; do
	if [[ ! -d "$DIR/$GH_REPO" ]]; then
		NEW_GH_REPOS_LIST+=("$GH_REPO")
  else
    if [[ $SKIP_COUNT -eq 0 ]]; then
      echo ""
    fi

    ((SKIP_COUNT++))

    echo "- Found existing repository $GH_REPO."
	fi
done

EXISTING_REPO_COUNT=$((${#GH_REPOS_LIST[@]} - ${#NEW_GH_REPOS_LIST[@]}))
NEW_REPO_COUNT=${#NEW_GH_REPOS_LIST[@]}

if [[ $NEW_REPO_COUNT -eq 0 ]]; then
  echo ""
  echo "* All repositories already present in $DIR, nothing to do."
  exit 0
fi

echo ""
echo "* Found $GH_REPOS_LIST_COUNT repositories."
echo "* $NEW_REPO_COUNT new repositories will be cloned in $DIR/"
echo "* $EXISTING_REPO_COUNT existing repositories will be skipped."
echo ""

REPOS=("${NEW_GH_REPOS_LIST[@]}")

export ARG_OWNER=$OWNER
export ARG_DIR=$DIR
export ARG_DEPTH=$DEPTH

clone_repos() {
  REPO="$1"
  CWD="$(pwd)"

  echo "- Cloning $ARG_OWNER/$REPO..."

  cd "$ARG_DIR" || exit 1

  if [[ "$ARG_DEPTH" -gt 0 ]]; then
   git clone --depth "$ARG_DEPTH" --mirror git@github.com:"$ARG_OWNER"/"$REPO" > /dev/null 2>&1
  else
   git clone --mirror git@github.com:"$ARG_OWNER"/"$REPO" > /dev/null 2>&1
  fi

  cd "$CWD" || exit 1
}

export -f clone_repos

parallel -j $JOBS clone_repos ::: "${REPOS[@]}"
